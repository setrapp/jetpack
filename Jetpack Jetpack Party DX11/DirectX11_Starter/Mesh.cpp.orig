#pragma once 
#include "Mesh.h"
#include "Vertex.h"
#include <stdio.h>

Mesh::Mesh(UINT* i, short noOfIndices)
{
<<<<<<< HEAD
	D3D11_BUFFER_DESC vbd;
    vbd.Usage					= D3D11_USAGE_IMMUTABLE;
	vbd.ByteWidth				= sizeof(Vertex) * noOfVertices; // Number of vertices
    vbd.BindFlags				= D3D11_BIND_VERTEX_BUFFER;
    vbd.CPUAccessFlags			= 0;
    vbd.MiscFlags				= 0;
	vbd.StructureByteStride		= 0;

	size_t a = sizeof(Vertex);

    D3D11_SUBRESOURCE_DATA initialVertexData;
    initialVertexData.pSysMem	= v;

    HR(DXConnection::Instance()->device->CreateBuffer(
		&vbd,
		&initialVertexData,
		&vertexBuffer));

	// Create the index buffer
	D3D11_BUFFER_DESC ibd;
    ibd.Usage					= D3D11_USAGE_IMMUTABLE;
    ibd.ByteWidth				= sizeof(UINT) * noOfIndices; // Number of indices
    ibd.BindFlags				= D3D11_BIND_INDEX_BUFFER;
    ibd.CPUAccessFlags			= 0;
    ibd.MiscFlags				= 0;
	ibd.StructureByteStride		= 0;

    D3D11_SUBRESOURCE_DATA initialIndexData;
    initialIndexData.pSysMem	= i;

    HR(DXConnection::Instance()->device->CreateBuffer(
		&ibd,
		&initialIndexData,
		&indexBuffer));
=======
	indices = (UINT*)calloc(noOfIndices, sizeof(UINT));
	indices = i;
>>>>>>> 13f511e527abf9272a6e0aa679e42563c914978d
	totalIndices = noOfIndices;
}


Mesh::~Mesh(void)
{
	delete indices;
}

UINT* Mesh::GetIndices(short** total)
{
	*total = &totalIndices;
	return indices;
}
		

void Update(float dt);

void Mesh::Draw()
{	
<<<<<<< HEAD
	const UINT stride = sizeof(Vertex);
	UINT offset = 0;

	DXConnection::Instance()->deviceContext->IASetVertexBuffers(0, 1, &vertexBuffer, &stride, &offset);
	DXConnection::Instance()->deviceContext->IASetIndexBuffer(indexBuffer, DXGI_FORMAT_R32_UINT, 0);

	DXConnection::Instance()->deviceContext->DrawIndexed(
		this->totalIndices,	// The number of indices we're using in this draw
		0,
		0);
=======
	
>>>>>>> 13f511e527abf9272a6e0aa679e42563c914978d
}